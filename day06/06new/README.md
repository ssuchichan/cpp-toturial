# 对象创建操作符：new/new[ ]

* 如果一个类重载了`new/new[]`操作符，那么当通过`new/new[]`创建该类对象/对象数组时，将首先调用该操作符函数分配内存，然后再调用该类的构造函数
  ```
  class 类名  {
  	static void* operator new(size_t size) { ... }
  	static void* operator new[](size_t size) { ... }
  };
  ```
* 包含自定义析构函数的类，通过`new[]`创建对象数组，所分配的内存会在低地址部分预留出`sizeof(size_t)`个字节，存放数组长度

# 对象销毁操作符：delete/delete[ ]

* 如果一个类重载了`delete/delete[]`操作符，那么当通过`delete/delete[]`销毁该类对象/对象数组时，将首先调用该类的析构函数，然后再调用该操作符函数释放内存
  ```
  class 类名 {
  	static void operator delete(void* p) { ... }
  	static void operator delete[](void* p) { ... }
  };
  ```
* 包含自定义析构函数的类，通过`delete[]`销毁对象数组，会根据低地址部分预留的数组长度，从高地址到低地址一次对每个数组元素调用析构函数

# 操作符重载的限制

* 不是富有的操作符都能重载，以下操作符不能重载
  * 作用限定操作符：`::`
  * 直接成员访问符：`.`
  * 直接成员指针解引用操作符：`.*`
  * 条件操作符：`?:`
  * 字节长度操作符：`sizeof`
  * 类型信息操作符：`typeid`
* 无法重载所有操作数均为基本类型的操作符
* 无法通过操作符重载改变操作符优先级
* 无法通过操作符重载改变操作数的个数
* 无法通过操作符重载发明新的操作符
* 操作符重载着力于对一致性的追求
* 操作符重载的价值在于提高代码的可读性，而不是沦为少"数算符"控们赖以生存的奇技淫巧









## 子类的构造与析构

* 子类构造函数隐式调用基类构造函数
    * 如果子类的构造函数没有显式指明其基类部分的构造方式，那么编译器会选择其基类的缺省构造函数，构造该子类对象中的基类子对象
* 子类构造函数显式调用基类构造函数
    * 子类的构造函数可以在`初始化表`中显式指明其基类部分的构造方式，即通过其基类的特定构造函数构造该子类对象中的基类子对象
* 子类对象的构造过程
    * 构造基类子对象->构造成员变量->执行构造代码
* 阻断继承
    * 子类的构造函数无论如何都会调用基类的构造函数，构造子类对象中的基类子对象
    * 如果把基类的构造函数定义为私有，那么该类的子类就永远无法实例化对象
    * 在C++中可以用这种方法阻断一个类被扩展
* 子类析构函数隐式调用基类析构函数
    * 子类的析构函数在执行完其中的析构代码，并析构完所有的成员变量以后，会自动调用其基类的析构函数，析构该子类对象中的基类子对象
* 基类析构函数不会调用子类析构函数
    * 通过基类指针析构子类对象，实际被析构的仅仅是子类对象中的基类子对象，子类的扩展部分将失去被析构的机会，极有可能形成内存泄漏
* 子类对象的析构过程
    * 执行析构代码->析构成员变量->析构基类子对象

## 子类的拷贝构造与拷贝赋值

* 子类没有定义拷贝构造函数
    * 编译器为子类提供的缺省拷贝构造函数，会自动调用其基类的拷贝构造函数，构造该子类对象中的基类子对象
* 子类定义了拷贝构造函数，但没有显式指明其基类部分的构造方式
    * 编译器会选择其基类的缺省构造函数，构造该子类对象中的基类子对象
* 子类定义了拷贝构造函数，同时显式指明了其基类部分以拷贝方式构造
    * 子类对象中的基类部分和扩展部分一起被复制
* 子类没有定义拷贝赋值运算符函数
    * 编译器为子类提供的缺省拷贝赋值运算符函数，会自动调用其基类的拷贝赋值运算符函数，复制该子类对象中的基类子对象
* 子类定义了拷贝赋值运算符函数，但没有显式调用其基类的拷贝赋值运算符函数
    * 子类对象中的基类子对象将得不到复制
* 子类定义了拷贝赋值运算符函数，同时显式调用了其基类的拷贝赋值运算符函数
    * 子类对象中的基类部分和扩展部分一起被复制

## 子类的操作符重载

* 在为子类提供操作符重载定义时，往往需要调用其基类针对该操作符所做的重载定义，完成部分工作
* 通过将子类对象的指针或引用向上造型为其基类类型的指针或引用，可以迫使针对基类的操作符重载函数在针对子类的操作符重载函数中被调用

  ```
  ostream& operator<<(ostream& os, const Manager& manager) {
  	return os <<(Employee&)manager << "," << manager.m_title;
  }
  ```



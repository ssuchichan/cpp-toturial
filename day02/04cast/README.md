# 显式类型转换

* C风格的显式类型转换
    * (目标类型变量)源类型变量
* C++风格的显式类型转换
    * 目标类型变量(源类型变量)
* 静态类型转换
    * `static_cast<目标类型>(源类型)`
      * 目标类型必须可以隐式地转换为源类型。即目标类型到源类型可以隐式转换，那么源类型到目标类型就可以静态转换。
    * 隐式类型转换的逆转换
    * 自定义类型转换
* 动态类型转换
  * `dynamic_cast<目标类型>(源类型变量)`
  * 多台父子类指针或引用之间的转换
* 常类型转换
  * `const_cast<目标类型>(源类型变量)`
  * 去除指针或引用上的const属性
* 重解释类型转换
  * `reinterpret_cast<目标类型>(源类型变量)`
  * 任意类型的指针或引用之间的转换
  * 任意类型的指针和整型之间的转换

# 来自C++社区的建议

* 用`const`取代常量宏

```c++
#define PI 3.14

const double PI = 3.14;
```

* 用`enum`取代唯一标识宏

```c++
#define RED 0
#define GREEN 1
#define BLUE 2
#define YELLOW 2 // 可能重复

enum COLOR { RED, GREEN, BLUE, YELLOW };
```

* 用`inline`取代参数宏
* 用`namespace`取代条件编译解决名字冲突
* 变量随用随声明，并立即初始化
* 少用`malloc/free`，`new/delete`更好
* 避免使用`void*`、指针算术、联合和强制类型转换
* 用`string`和`STL`容器取代低级数组
* 树立面向对象的编程思想，程序设计的过程是用类描述世界的过程，而非用函数处理数据的过程

